{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Suthing","text":"<p>SUThing /\u02c8su.\u03b8\u026a\u014b/ or /\u02c8s\u028c.\u03b8\u026a\u014b/ (Some Useful Things) is a collection of useful classes and decorators.  </p> <p>A Python utility package providing tools for file handling, timing, profiling, and data comparison.</p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>File Handling: one-line file reading/writing with file format inference from provided extension (YAML, JSON, CSV, pickle, gz etc.)</li> <li>Performance Measurement: Simple timer utilities and profiling decorators</li> <li>Data Comparison: Deep comparison of nested data structures</li> <li>Error Handling: Decorators for secure function execution and error tracking</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from suthing import FileHandle, Timer, profile, equals\n\n# Read a file\ndata = FileHandle.load(\"config.yaml\")\n\n# Time your code\nwith Timer() as t:\n    # Your code here\n    pass\nprint(f\"Execution took {t.elapsed_str}\")\n\n# Compare complex structures\nresult = equals(dict1, dict2)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Explore the documentation to learn more about Suthing's features:</p> <ul> <li>Getting Started - Learn how to install and use Suthing</li> </ul> <ul> <li>API Reference - Complete API documentation</li> <li>Examples - Code examples and usage patterns</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>pandas</li> <li>PyYAML</li> <li>python-dotenv</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please check out our Contributing Guide for details on how to get started.</p>"},{"location":"contributing/","title":"Contributing to Suthing","text":"<p>We welcome contributions to Suthing! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Install the development dependencies:    <pre><code>uv sync --dev\n</code></pre></li> <li>Install pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a new branch for your feature or bugfix:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes and ensure tests pass:    <pre><code>pytest test\n</code></pre></p> </li> <li> <p>Commit your changes with a descriptive message:    <pre><code>git commit -m \"Add feature: your feature description\"\n</code></pre></p> </li> <li> <p>Push your branch to your fork:    <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> <li> <p>Create a Pull Request on GitHub</p> </li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use type hints for all function parameters and return values</li> <li>Write docstrings following the Google style</li> <li>Keep functions focused and small</li> <li>Add tests for new features</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Update relevant documentation when adding new features</li> <li>Add docstrings to all new functions and classes</li> <li>Include examples in docstrings where appropriate</li> <li>Update the changelog for significant changes</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for all new features</li> <li>Ensure all tests pass before submitting a PR</li> <li>Add tests for bug fixes</li> <li>Maintain or improve test coverage</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your PR description clearly describes the problem and solution</li> <li>Include relevant tests</li> <li>Update documentation as needed</li> <li>Ensure all CI checks pass</li> <li>Request review from maintainers</li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting issues, please include:</p> <ul> <li>Python version</li> <li>Suthing version</li> <li>Steps to reproduce</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Any relevant error messages</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to Suthing, you agree that your contributions will be licensed under the project's MIT License. </p>"},{"location":"examples/","title":"Examples","text":"<p>This page contains practical examples of using Suthing in real-world scenarios.</p>"},{"location":"examples/#configuration-management","title":"Configuration Management","text":"<p>Load and manage configuration files with automatic format detection:</p> <pre><code>from suthing import FileHandle\nfrom pathlib import Path\n\n# Load configuration from different formats\nconfig = FileHandle.load(\"config.yaml\")\nenv_vars = FileHandle.load(\".env\")\ncredentials = FileHandle.load(\"secrets.json\")\n\n# Save configuration with compression\nFileHandle.dump(config, \"config.json.gz\")\n</code></pre>"},{"location":"examples/#performance-optimization","title":"Performance Optimization","text":"<p>Identify bottlenecks in your code:</p> <pre><code>from suthing import Timer, profile, SProfiler\n\n# Time a specific operation\nwith Timer() as t:\n    result = process_large_dataset()\nprint(f\"Dataset processing took {t.elapsed_str}\")\n\n# Profile a function with different inputs\nprofiler = SProfiler()\n\n@profile(_argnames=[\"size\", \"batch_size\"])\ndef process_data(size, batch_size):\n    for i in range(0, size, batch_size):\n        process_batch(i, batch_size)\n\n# Run with different parameters\nprocess_data(size=1000, batch_size=100, _profiler=profiler)\nprocess_data(size=1000, batch_size=50, _profiler=profiler)\n\n# Compare performance\nstats = profiler.view_stats()\n</code></pre>"},{"location":"examples/#database-connection-management","title":"Database Connection Management","text":"<p>Create and manage database connections with automatic type detection:</p> <pre><code>from suthing.connection import ConfigFactory\n\n# ArangoDB connection\narango_config = ConfigFactory.create_config(url=\"http://localhost:8529\")\n\n# Neo4j connection\nneo4j_config = ConfigFactory.create_config(dict_like={\n    \"port\": \"7474\",\n    \"username\": \"neo4j\",\n    \"password\": \"password\"\n})\n\n# WSGI application\nwsgi_config = ConfigFactory.create_config(dict_like={\n    \"port\": \"8000\",\n    \"host\": \"0.0.0.0\",\n    \"path\": \"/api\"\n})\n</code></pre>"},{"location":"examples/#data-validation","title":"Data Validation","text":"<p>Compare and validate complex data structures:</p> <pre><code>from suthing import equals\n\n# Compare configuration files\nconfig1 = FileHandle.load(\"config1.yaml\")\nconfig2 = FileHandle.load(\"config2.yaml\")\nif not equals(config1, config2):\n    print(\"Configurations differ!\")\n\n# Compare nested data structures\nexpected = {\n    \"users\": [\n        {\"id\": 1, \"name\": \"Alice\"},\n        {\"id\": 2, \"name\": \"Bob\"}\n    ],\n    \"settings\": {\"theme\": \"dark\", \"notifications\": True}\n}\n\nactual = {\n    \"users\": [\n        {\"id\": 1, \"name\": \"Alice\"},\n        {\"id\": 2, \"name\": \"Bob\"}\n    ],\n    \"settings\": {\"theme\": \"dark\", \"notifications\": True}\n}\n\nif equals(expected, actual):\n    print(\"Data matches expected structure\")\n</code></pre>"},{"location":"examples/#error-handling","title":"Error Handling","text":"<p>Use decorators for secure function execution:</p> <pre><code>from suthing import secure_execution\n\n@secure_execution\ndef process_sensitive_data(data):\n    # Your code here\n    return result\n\n# The function will handle errors gracefully\nresult = process_sensitive_data(data)\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>For more detailed examples and use cases, check out:</p> <ul> <li>API Reference - Complete API documentation</li> <li>Quick Start - Basic usage examples</li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"getting_started/installation/#installation-steps","title":"Installation Steps","text":"<ol> <li>Install Suthing using pip:</li> </ol> <pre><code>pip install suthing\n</code></pre> <ol> <li>Verify the installation:</li> </ol> <pre><code>import suthing\nprint(suthing.__version__)\n</code></pre>"},{"location":"getting_started/installation/#dependencies","title":"Dependencies","text":"<p>Suthing requires the following packages:</p> <ul> <li>pandas</li> <li>PyYAML</li> <li>python-dotenv</li> </ul> <p>These will be automatically installed when you install Suthing using pip.</p>"},{"location":"getting_started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to Suthing or run the tests:</p> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/growgraph/suthing.git\ncd suthing\n</code></pre></p> </li> <li> <p>Install in development mode: <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Install pre-commit hooks: <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"getting_started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues during installation:</p> <ol> <li>Make sure you have Python 3.10 or higher installed</li> <li>Try upgrading pip: <code>pip install --upgrade pip</code></li> <li>Check if all dependencies are properly installed</li> <li>If problems persist, please open an issue on GitHub </li> </ol>"},{"location":"getting_started/quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with Suthing quickly. We'll cover the main features with simple examples.</p>"},{"location":"getting_started/quickstart/#file-handling","title":"File Handling","text":"<p>Suthing makes file operations simple with automatic format detection:</p> <pre><code>from suthing import FileHandle\n\n# Read a YAML file\ndata = FileHandle.load(\"config.yaml\")\n\n# Write to a compressed JSON file\nFileHandle.dump(data, \"output.json.gz\")\n</code></pre>"},{"location":"getting_started/quickstart/#performance-measurement","title":"Performance Measurement","text":"<p>Time your code execution easily:</p> <pre><code>from suthing import Timer\n\nwith Timer() as t:\n    # Your code here\n    result = some_expensive_operation()\nprint(f\"Operation took {t.elapsed_str}\")\n</code></pre>"},{"location":"getting_started/quickstart/#profiling-functions","title":"Profiling Functions","text":"<p>Profile your functions to understand their performance:</p> <pre><code>from suthing import profile, SProfiler\n\nprofiler = SProfiler()\n\n@profile(_argnames=\"input_size\")\ndef process_data(input_size):\n    # Process data based on input size\n    return result\n\n# Run with profiler\nresult = process_data(input_size=100, _profiler=profiler)\n\n# View profiling results\nstats = profiler.view_stats()\n</code></pre>"},{"location":"getting_started/quickstart/#data-comparison","title":"Data Comparison","text":"<p>Compare complex data structures:</p> <pre><code>from suthing import equals\n\n# Compare nested dictionaries\ndict1 = {\"a\": {\"b\": 1, \"c\": [1, 2, 3]}}\ndict2 = {\"a\": {\"b\": 1, \"c\": [1, 2, 3]}}\nresult = equals(dict1, dict2)  # True\n</code></pre>"},{"location":"getting_started/quickstart/#connection-management","title":"Connection Management","text":"<p>Create and manage database connections:</p> <pre><code>from suthing.connection import ConfigFactory\n\n# Create a connection from URL\nconfig = ConfigFactory.create_config(url=\"http://localhost:8529\")\n# This will automatically detect it's an ArangoDB connection based on port\n\n# Or from a dictionary\nconfig = ConfigFactory.create_config(dict_like={\n    \"port\": \"8529\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n})\n</code></pre>"},{"location":"getting_started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Check out more Examples</li> <li>Read the complete API Reference </li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Welcome to the Suthing API Reference documentation. This section contains detailed documentation for all modules and classes.</p>"},{"location":"reference/#core-modules","title":"Core Modules","text":"<ul> <li>File Handling - Utilities for file operations</li> <li>Timer - Performance measurement tools</li> <li>Profiler - Function profiling utilities</li> <li>Comparison - Deep data structure comparison</li> </ul>"},{"location":"reference/#connection-modules","title":"Connection Modules","text":"<ul> <li>Connection Types - Supported connection types</li> <li>Configuration - Connection configuration classes</li> <li>Factories - Connection factory utilities</li> </ul>"},{"location":"reference/#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Basic usage examples</li> <li>Examples - Practical use cases</li> <li>Contributing - How to contribute </li> </ul>"},{"location":"reference/connection/","title":"Connection Module","text":"<p>The connection module provides utilities for managing different types of connections (ArangoDB, Neo4j, WSGI).</p>"},{"location":"reference/connection/#connection-types","title":"Connection Types","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum representing different types of connections.</p> Source code in <code>suthing/connection/onto.py</code> <pre><code>class ConnectionKind(str, Enum, metaclass=EnumMetaWithContains):\n    \"\"\"Enum representing different types of connections.\"\"\"\n\n    ARANGO = \"arango\"\n    NEO4J = \"neo4j\"\n    WSGI = \"wsgi\"\n    # Can add more connection types here\n\n    @property\n    def config_class(self) -&gt; Type[\"ConnectionConfig\"]:\n        \"\"\"Get the appropriate config class for this connection type.\"\"\"\n        from .config_mapping import CONNECTION_TYPE_MAPPING\n\n        return CONNECTION_TYPE_MAPPING[self]\n</code></pre>"},{"location":"reference/connection/#suthing.connection.onto.ConnectionKind.config_class","title":"<code>config_class</code>  <code>property</code>","text":"<p>Get the appropriate config class for this connection type.</p>"},{"location":"reference/connection/#connection-configuration","title":"Connection Configuration","text":"<p>               Bases: <code>JSONWizard</code>, <code>Meta</code></p> <p>Base class for all connection configurations.</p> Source code in <code>suthing/connection/onto.py</code> <pre><code>@dataclasses.dataclass\nclass ConnectionConfig(JSONWizard, JSONWizard.Meta):\n    \"\"\"Base class for all connection configurations.\"\"\"\n\n    connection_type: Optional[ConnectionKind] = None\n    comment: Optional[str] = None\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"ConnectionConfig\":\n        \"\"\"Create a connection config from a dictionary.\"\"\"\n        if not isinstance(data, dict):\n            raise TypeError(f\"Expected dict, got {type(data)}\")\n\n        db_type = data.pop(\"db_type\", None) or data.pop(\"connection_type\", None)\n        if not db_type:\n            raise ValueError(\"Missing 'db_type' or 'connection_type' in configuration\")\n\n        try:\n            conn_type = ConnectionKind(db_type)\n        except ValueError:\n            raise ValueError(\n                f\"Connection type '{db_type}' not supported. \"\n                f\"Should be one of: {list(ConnectionKind)}\"\n            )\n\n        # Copy the data to avoid modifying the original\n        config_data = data.copy()\n        # Get the appropriate config class and initialize it\n        config_class = conn_type.config_class\n        return config_class(**config_data)\n</code></pre> <p>               Bases: <code>ConnectionConfig</code></p> <p>Configuration for protocol-based connections.</p> Source code in <code>suthing/connection/onto.py</code> <pre><code>@dataclasses.dataclass\nclass ProtoConnectionConfig(ConnectionConfig):\n    \"\"\"Configuration for protocol-based connections.\"\"\"\n\n    url: Optional[str] = None\n    hosts: Optional[str] = None\n    hostname: Optional[str] = None\n    port: Optional[str] = None\n    protocol: str = \"http\"\n    request_timeout: float = 60\n\n    def __post_init__(self):\n        \"\"\"Process the connection information after initialization.\"\"\"\n        # Process URL if provided, otherwise build from components\n        if self.hosts and not self.url:\n            self.url = self.hosts\n        if self.url:\n            self._parse_url()\n        elif self.hostname:\n            self.url = f\"{self.protocol}://{self.hostname}\"\n        elif self.port:\n            self.url = f\"{self.url}:{self.port}\"\n\n    def _parse_url(self):\n        \"\"\"Parse the URL into components.\"\"\"\n        if not self.url:\n            return\n\n        parsed = urlparse(self.url)\n\n        # Extract protocol\n        if parsed.scheme:\n            self.protocol = parsed.scheme\n\n        # Extract port\n        if parsed.port:\n            self.port = str(parsed.port)\n\n        return parsed\n</code></pre> <p>               Bases: <code>ProtoConnectionConfig</code></p> <p>Configuration for database connections.</p> Source code in <code>suthing/connection/onto.py</code> <pre><code>@dataclasses.dataclass\nclass DBConnectionConfig(ProtoConnectionConfig):\n    \"\"\"Configuration for database connections.\"\"\"\n\n    username: Optional[str] = None\n    password: Optional[str] = None\n    database: Optional[str] = None\n\n    # Backward compatibility\n    cred_name: Optional[str] = None\n    cred_pass: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Process after initialization and handle credential aliases.\"\"\"\n        super().__post_init__()\n\n        # Handle credential aliases for backward compatibility\n        if not self.username and self.cred_name:\n            self.username = self.cred_name\n\n        if not self.password and self.cred_pass:\n            self.password = self.cred_pass\n</code></pre>"},{"location":"reference/connection/#suthing.connection.onto.ConnectionConfig.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a connection config from a dictionary.</p> Source code in <code>suthing/connection/onto.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"ConnectionConfig\":\n    \"\"\"Create a connection config from a dictionary.\"\"\"\n    if not isinstance(data, dict):\n        raise TypeError(f\"Expected dict, got {type(data)}\")\n\n    db_type = data.pop(\"db_type\", None) or data.pop(\"connection_type\", None)\n    if not db_type:\n        raise ValueError(\"Missing 'db_type' or 'connection_type' in configuration\")\n\n    try:\n        conn_type = ConnectionKind(db_type)\n    except ValueError:\n        raise ValueError(\n            f\"Connection type '{db_type}' not supported. \"\n            f\"Should be one of: {list(ConnectionKind)}\"\n        )\n\n    # Copy the data to avoid modifying the original\n    config_data = data.copy()\n    # Get the appropriate config class and initialize it\n    config_class = conn_type.config_class\n    return config_class(**config_data)\n</code></pre>"},{"location":"reference/connection/#suthing.connection.onto.ProtoConnectionConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Process the connection information after initialization.</p> Source code in <code>suthing/connection/onto.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Process the connection information after initialization.\"\"\"\n    # Process URL if provided, otherwise build from components\n    if self.hosts and not self.url:\n        self.url = self.hosts\n    if self.url:\n        self._parse_url()\n    elif self.hostname:\n        self.url = f\"{self.protocol}://{self.hostname}\"\n    elif self.port:\n        self.url = f\"{self.url}:{self.port}\"\n</code></pre>"},{"location":"reference/connection/#suthing.connection.onto.DBConnectionConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Process after initialization and handle credential aliases.</p> Source code in <code>suthing/connection/onto.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Process after initialization and handle credential aliases.\"\"\"\n    super().__post_init__()\n\n    # Handle credential aliases for backward compatibility\n    if not self.username and self.cred_name:\n        self.username = self.cred_name\n\n    if not self.password and self.cred_pass:\n        self.password = self.cred_pass\n</code></pre>"},{"location":"reference/connection/#connection-factories","title":"Connection Factories","text":"<p>Factory for creating connection configurations from various sources.</p> Source code in <code>suthing/connection/factory.py</code> <pre><code>class ConfigFactory:\n    \"\"\"Factory for creating connection configurations from various sources.\"\"\"\n\n    @staticmethod\n    def _guess_connection_kind_from_port(port: int) -&gt; Optional[ConnectionKind]:\n        \"\"\"Guess the connection kind based on port number.\n\n        Args:\n            port: Port number to check\n\n        Returns:\n            Guessed ConnectionKind or None if no match\n        \"\"\"\n        if 8529 &lt;= port &lt;= 8559:\n            return ConnectionKind.ARANGO\n        elif 7400 &lt;= port &lt;= 7699:\n            return ConnectionKind.NEO4J\n        return None\n\n    @staticmethod\n    def _extract_port_from_config(config: Dict[str, Any]) -&gt; Optional[int]:\n        \"\"\"Extract port number from configuration dictionary.\n\n        Args:\n            config: Configuration dictionary\n\n        Returns:\n            Port number if found, None otherwise\n        \"\"\"\n        # Check direct port field\n        if \"port\" in config:\n            try:\n                return int(config[\"port\"])\n            except (ValueError, TypeError):\n                pass\n\n        # Check URL if present\n        if \"url\" in config:\n            parsed_url = urlparse(config[\"url\"])\n            if parsed_url.port:\n                return parsed_url.port\n            elif parsed_url.scheme == \"http\":\n                return 80\n            elif parsed_url.scheme == \"https\":\n                return 443\n\n        return None\n\n    @classmethod\n    def create_config(\n        cls,\n        *args,\n        **kwargs,\n    ) -&gt; ConnectionConfig:\n        \"\"\"\n        Create a connection configuration from a file path, dictionary, or URL.\n\n        Args:\n            path: Path to a JSON or YAML configuration file\n            dict_like: Dictionary containing configuration parameters\n            url: URL string to create a connection directly\n\n        Returns:\n            A properly typed connection configuration object\n\n        Raises:\n            ValueError: If no valid input source is provided or if connection type is invalid\n        \"\"\"\n        # Handle URL-based configuration\n        url: Optional[str] = kwargs.get(\"url\", None)\n        path: Optional[str | Path] = kwargs.get(\"path\", None)\n        dict_like: Optional[Dict[str, Any]] = kwargs.get(\"dict_like\", None)\n        if len(args) &gt; 0:\n            arg = args[0]\n            if isinstance(arg, dict):\n                dict_like = arg\n            elif isinstance(arg, Path):\n                path = arg\n            elif isinstance(arg, str):\n                if is_filepath(arg):\n                    path = arg\n                else:\n                    url = arg\n\n        if url:\n            # Parse URL to get port\n            parsed_url = urlparse(url)\n            port = None\n            if parsed_url.port:\n                port = parsed_url.port\n            elif parsed_url.scheme == \"http\":\n                port = 80\n            elif parsed_url.scheme == \"https\":\n                port = 443\n\n            # Start with an empty config and add the URL\n            config = {\"url\": url}\n\n            # Try to guess connection kind from port\n            if port:\n                guessed_kind = cls._guess_connection_kind_from_port(port)\n                if guessed_kind:\n                    config[\"connection_type\"] = guessed_kind.value\n\n        # Handle file-based configuration\n        elif path is not None:\n            config = FileHandle.load(path)\n        # Handle dictionary-based configuration\n        elif dict_like is not None and isinstance(dict_like, dict):\n            config = deepcopy(dict_like)\n        else:\n            raise ValueError(\n                \"At least one of the arguments must be provided: path, dict_like, or url\"\n            )\n\n        # Try to guess connection kind from port in config if not already set\n        if \"connection_type\" not in config:\n            port = cls._extract_port_from_config(config)\n            if port:\n                guessed_kind = cls._guess_connection_kind_from_port(port)\n                if guessed_kind:\n                    config[\"connection_type\"] = guessed_kind.value\n\n        return ConnectionConfig.from_dict(config)\n</code></pre>"},{"location":"reference/connection/#suthing.connection.factory.ConfigFactory.create_config","title":"<code>create_config(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a connection configuration from a file path, dictionary, or URL.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>Path to a JSON or YAML configuration file</p> required <code>dict_like</code> <p>Dictionary containing configuration parameters</p> required <code>url</code> <p>URL string to create a connection directly</p> required <p>Returns:</p> Type Description <code>ConnectionConfig</code> <p>A properly typed connection configuration object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid input source is provided or if connection type is invalid</p> Source code in <code>suthing/connection/factory.py</code> <pre><code>@classmethod\ndef create_config(\n    cls,\n    *args,\n    **kwargs,\n) -&gt; ConnectionConfig:\n    \"\"\"\n    Create a connection configuration from a file path, dictionary, or URL.\n\n    Args:\n        path: Path to a JSON or YAML configuration file\n        dict_like: Dictionary containing configuration parameters\n        url: URL string to create a connection directly\n\n    Returns:\n        A properly typed connection configuration object\n\n    Raises:\n        ValueError: If no valid input source is provided or if connection type is invalid\n    \"\"\"\n    # Handle URL-based configuration\n    url: Optional[str] = kwargs.get(\"url\", None)\n    path: Optional[str | Path] = kwargs.get(\"path\", None)\n    dict_like: Optional[Dict[str, Any]] = kwargs.get(\"dict_like\", None)\n    if len(args) &gt; 0:\n        arg = args[0]\n        if isinstance(arg, dict):\n            dict_like = arg\n        elif isinstance(arg, Path):\n            path = arg\n        elif isinstance(arg, str):\n            if is_filepath(arg):\n                path = arg\n            else:\n                url = arg\n\n    if url:\n        # Parse URL to get port\n        parsed_url = urlparse(url)\n        port = None\n        if parsed_url.port:\n            port = parsed_url.port\n        elif parsed_url.scheme == \"http\":\n            port = 80\n        elif parsed_url.scheme == \"https\":\n            port = 443\n\n        # Start with an empty config and add the URL\n        config = {\"url\": url}\n\n        # Try to guess connection kind from port\n        if port:\n            guessed_kind = cls._guess_connection_kind_from_port(port)\n            if guessed_kind:\n                config[\"connection_type\"] = guessed_kind.value\n\n    # Handle file-based configuration\n    elif path is not None:\n        config = FileHandle.load(path)\n    # Handle dictionary-based configuration\n    elif dict_like is not None and isinstance(dict_like, dict):\n        config = deepcopy(dict_like)\n    else:\n        raise ValueError(\n            \"At least one of the arguments must be provided: path, dict_like, or url\"\n        )\n\n    # Try to guess connection kind from port in config if not already set\n    if \"connection_type\" not in config:\n        port = cls._extract_port_from_config(config)\n        if port:\n            guessed_kind = cls._guess_connection_kind_from_port(port)\n            if guessed_kind:\n                config[\"connection_type\"] = guessed_kind.value\n\n    return ConnectionConfig.from_dict(config)\n</code></pre>"},{"location":"reference/core/","title":"Core Module","text":"<p>The core module provides essential utilities for file handling, timing, and data comparison.</p>"},{"location":"reference/core/#file-handling","title":"File Handling","text":"<p>Main class for handling file operations across different formats.</p> Source code in <code>suthing/file_handle.py</code> <pre><code>class FileHandle:\n    \"\"\"Main class for handling file operations across different formats.\"\"\"\n\n    @classmethod\n    def _find_mode(cls, lemma: str):\n        \"\"\"Determine file type from file extension.\n\n        Args:\n            lemma: File extension string\n\n        Returns:\n            FileType enum value corresponding to the extension\n        \"\"\"\n        if lemma in [\".yml\", \".yaml\"]:\n            return FileType.YAML\n        elif lemma == \".json\":\n            return FileType.JSON\n        elif lemma == \".jsonld\":\n            return FileType.JSONLD\n        elif lemma in [\".pkl\", \".pickle\"]:\n            return FileType.PICKLE\n        elif lemma in [\".csv\"]:\n            return FileType.CSV\n        elif lemma in [\".env\"]:\n            return FileType.ENV\n        else:\n            return FileType.TXT\n\n    @classmethod\n    def _dump_pointer(cls, item, p, how: FileType, bytes_: bool = True) -&gt; None:\n        \"\"\"Write data to file pointer in specified format.\n\n        Args:\n            item: Data to write\n            p: File pointer\n            how: FileType indicating format to write in\n            bytes_: Whether to write in bytes mode\n        \"\"\"\n        if how == FileType.PICKLE:\n            pickle.dump(item, p, pickle.HIGHEST_PROTOCOL)\n        elif how == FileType.YAML:\n            yc = yaml.dump(item)\n            if bytes_:\n                yc = yc.encode(\"utf-8\")  # type: ignore\n            p.write(yc)\n        elif how == FileType.JSON:\n            jc = json.dumps(item, indent=2) + \"\\n\"\n            if bytes_:\n                jc = jc.encode(\"utf-8\")  # type: ignore\n            p.write(jc)\n        elif how == FileType.JSONLD:\n            for subitem in item:\n                jc = json.dumps(subitem) + \"\\n\"\n                if bytes_:\n                    jc = jc.encode(\"utf-8\")  # type: ignore\n                p.write(jc)\n        elif how == FileType.CSV and (\n            isinstance(item, pd.DataFrame) or isinstance(item, pd.Series)\n        ):\n            r = item.to_csv()\n            if bytes_:\n                r = r.encode(\"utf-8\")  # type: ignore\n            p.write(r)\n        elif how == FileType.TXT:\n            p.write(str(item))\n\n    @classmethod\n    def _open_pointer(cls, p: io.BytesIO | gzip.GzipFile, how: FileType, **kwargs):\n        \"\"\"Read data from file pointer in specified format.\n\n        Args:\n            p: File pointer\n            how: FileType indicating format to read\n            **kwargs: Additional arguments passed to readers\n\n        Returns:\n            Data read from file in appropriate format\n\n        Raises:\n            ValueError: If trying to read gzipped env files\n        \"\"\"\n        if how == FileType.PICKLE:\n            r = pickle.load(p)\n        elif how == FileType.YAML:\n            r = yaml.load(p, Loader=yaml.FullLoader)\n        elif how == FileType.JSON:\n            r = json.load(p)\n        elif how == FileType.JSONLD:\n            r = [json.loads(s.decode()) for s in p.readlines()]\n        elif how == FileType.CSV:\n            r = pd.read_csv(p, **kwargs)  # type: ignore[arg-type]\n        elif how == FileType.TXT:\n            r = p.read().decode()\n        elif how == FileType.ENV:\n            if isinstance(p, io.BytesIO):\n                config = io.StringIO(p.getvalue().decode(\"UTF-8\"))\n                r = load_dotenv(stream=config)\n            else:\n                raise ValueError(\"Will not read gzipped env files\")\n        else:\n            r = dict()\n        return r\n\n    @classmethod\n    def load(\n        cls,\n        ppath: str | pathlib.Path | None = None,\n        pname: str | None = None,\n        how: FileType = FileType.YAML,\n        **kwargs,\n    ):\n        \"\"\"\n\n        :param ppath:\n        :param pname:\n        :param how:\n        :param kwargs:\n        :return:\n        \"\"\"\n\n        compression = kwargs.pop(\"compression\", None)\n        fpath: str | pathlib.Path | None = kwargs.pop(\"fpath\", None)\n\n        # assume loading from a package\n        if pname is not None:\n            lemmas = suffixes(pname)\n            if lemmas[-1] == \".gz\":\n                compression = \"gz\"\n                how_ = cls._find_mode(lemmas[-2])\n            else:\n                how_ = cls._find_mode(lemmas[-1])\n            if how_:\n                how = how_\n            if ppath is not None and isinstance(ppath, str):\n                bytes_ = pkgutil.get_data(ppath, pname)\n            else:\n                raise ValueError(\n                    \"package name provided, package path (as a string) needed\"\n                )\n\n        # interpret as filesystem load\n        else:\n            if fpath is None:\n                if ppath is not None:\n                    fpath = ppath\n                else:\n                    raise ValueError(\"either fpath or ppath should be provided\")\n            fpath = pathlib.Path(fpath).expanduser().as_posix()\n            lemmas = suffixes(fpath)\n            if lemmas[-1] == \".gz\":\n                compression = \"gz\"\n                how_ = cls._find_mode(lemmas[-2])\n            else:\n                how_ = cls._find_mode(lemmas[-1])\n            if how_:\n                how = how_\n            with open(fpath, \"rb\") as fp:\n                bytes_ = fp.read()\n\n        if bytes_ is None:\n            raise ValueError(\"None received as Bytes\")\n\n        if compression == \"gz\":\n            with gzip.GzipFile(fileobj=io.BytesIO(bytes_), mode=\"r\") as p:\n                r = cls._open_pointer(p, how, **kwargs)\n        else:\n            with io.BytesIO(bytes_) as p:\n                r = cls._open_pointer(p, how, **kwargs)\n        return r\n\n    @classmethod\n    def dump(cls, item, path: str | pathlib.Path, how: FileType = FileType.YAML):\n        \"\"\"\n\n        :param item:\n        :param path: if path ends with \".gz\" the output will be gzip compressed\n        :param how:\n        :return:\n        \"\"\"\n\n        lemmas = suffixes(path)\n        path = pathlib.Path(path).expanduser().as_posix()\n        if lemmas[-1] == \".gz\":\n            compression = \"gz\"\n            how_ = cls._find_mode(lemmas[-2])\n        else:\n            compression = None\n            how_ = cls._find_mode(lemmas[-1])\n        if how_:\n            how = how_\n        if how == FileType.PICKLE:\n            mode = \"wb\"\n        else:\n            mode = \"w\"\n        if compression == \"gz\":\n            if not path.endswith(\".gz\"):\n                path += \".gz\"\n            with gzip.GzipFile(path, mode=mode) as p:\n                cls._dump_pointer(item, p, how)\n        else:\n            with open(path, mode=mode) as p:\n                cls._dump_pointer(item, p, how, bytes_=False)\n</code></pre>"},{"location":"reference/core/#suthing.file_handle.FileHandle.dump","title":"<code>dump(item, path, how=FileType.YAML)</code>  <code>classmethod</code>","text":"<p>:param item: :param path: if path ends with \".gz\" the output will be gzip compressed :param how: :return:</p> Source code in <code>suthing/file_handle.py</code> <pre><code>@classmethod\ndef dump(cls, item, path: str | pathlib.Path, how: FileType = FileType.YAML):\n    \"\"\"\n\n    :param item:\n    :param path: if path ends with \".gz\" the output will be gzip compressed\n    :param how:\n    :return:\n    \"\"\"\n\n    lemmas = suffixes(path)\n    path = pathlib.Path(path).expanduser().as_posix()\n    if lemmas[-1] == \".gz\":\n        compression = \"gz\"\n        how_ = cls._find_mode(lemmas[-2])\n    else:\n        compression = None\n        how_ = cls._find_mode(lemmas[-1])\n    if how_:\n        how = how_\n    if how == FileType.PICKLE:\n        mode = \"wb\"\n    else:\n        mode = \"w\"\n    if compression == \"gz\":\n        if not path.endswith(\".gz\"):\n            path += \".gz\"\n        with gzip.GzipFile(path, mode=mode) as p:\n            cls._dump_pointer(item, p, how)\n    else:\n        with open(path, mode=mode) as p:\n            cls._dump_pointer(item, p, how, bytes_=False)\n</code></pre>"},{"location":"reference/core/#suthing.file_handle.FileHandle.load","title":"<code>load(ppath=None, pname=None, how=FileType.YAML, **kwargs)</code>  <code>classmethod</code>","text":"<p>:param ppath: :param pname: :param how: :param kwargs: :return:</p> Source code in <code>suthing/file_handle.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    ppath: str | pathlib.Path | None = None,\n    pname: str | None = None,\n    how: FileType = FileType.YAML,\n    **kwargs,\n):\n    \"\"\"\n\n    :param ppath:\n    :param pname:\n    :param how:\n    :param kwargs:\n    :return:\n    \"\"\"\n\n    compression = kwargs.pop(\"compression\", None)\n    fpath: str | pathlib.Path | None = kwargs.pop(\"fpath\", None)\n\n    # assume loading from a package\n    if pname is not None:\n        lemmas = suffixes(pname)\n        if lemmas[-1] == \".gz\":\n            compression = \"gz\"\n            how_ = cls._find_mode(lemmas[-2])\n        else:\n            how_ = cls._find_mode(lemmas[-1])\n        if how_:\n            how = how_\n        if ppath is not None and isinstance(ppath, str):\n            bytes_ = pkgutil.get_data(ppath, pname)\n        else:\n            raise ValueError(\n                \"package name provided, package path (as a string) needed\"\n            )\n\n    # interpret as filesystem load\n    else:\n        if fpath is None:\n            if ppath is not None:\n                fpath = ppath\n            else:\n                raise ValueError(\"either fpath or ppath should be provided\")\n        fpath = pathlib.Path(fpath).expanduser().as_posix()\n        lemmas = suffixes(fpath)\n        if lemmas[-1] == \".gz\":\n            compression = \"gz\"\n            how_ = cls._find_mode(lemmas[-2])\n        else:\n            how_ = cls._find_mode(lemmas[-1])\n        if how_:\n            how = how_\n        with open(fpath, \"rb\") as fp:\n            bytes_ = fp.read()\n\n    if bytes_ is None:\n        raise ValueError(\"None received as Bytes\")\n\n    if compression == \"gz\":\n        with gzip.GzipFile(fileobj=io.BytesIO(bytes_), mode=\"r\") as p:\n            r = cls._open_pointer(p, how, **kwargs)\n    else:\n        with io.BytesIO(bytes_) as p:\n            r = cls._open_pointer(p, how, **kwargs)\n    return r\n</code></pre>"},{"location":"reference/core/#timer","title":"Timer","text":"<p>Context manager for timing code execution.</p> Source code in <code>suthing/timer.py</code> <pre><code>class Timer:\n    \"\"\"Context manager for timing code execution.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize timer with default settings.\"\"\"\n        self.timer = default_timer\n        self.mins = 0\n        self.secs = 0\n        self.elapsed = 0\n\n    def __enter__(self):\n        \"\"\"Start timing on context enter.\n\n        Returns:\n            self: Timer instance\n        \"\"\"\n        self.start = self.timer()\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Stop timing on context exit and calculate elapsed time.\"\"\"\n        end = self.timer()\n        self.elapsed = end - self.start\n        self.mins = int(self.elapsed / seconds_per_minute)\n        self.secs = int(self.elapsed - (self.mins * seconds_per_minute))\n\n    @property\n    def elapsed_str(self, digits: int = 2) -&gt; str:\n        \"\"\"Get formatted string of elapsed time.\n\n        Args:\n            digits: Number of decimal places for seconds\n\n        Returns:\n            Formatted time string (e.g. \"1 min 30.5 sec\")\n        \"\"\"\n        mins = int(self.elapsed / seconds_per_minute)\n        secs = round(self.elapsed - (mins * seconds_per_minute), digits)\n        r = f\"{secs} sec\"\n        if mins &gt; 0:\n            r = f\"{mins} min \" + r\n        return r\n</code></pre>"},{"location":"reference/core/#suthing.timer.Timer.elapsed_str","title":"<code>elapsed_str</code>  <code>property</code>","text":"<p>Get formatted string of elapsed time.</p> <p>Parameters:</p> Name Type Description Default <code>digits</code> <p>Number of decimal places for seconds</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted time string (e.g. \"1 min 30.5 sec\")</p>"},{"location":"reference/core/#suthing.timer.Timer.__enter__","title":"<code>__enter__()</code>","text":"<p>Start timing on context enter.</p> <p>Returns:</p> Name Type Description <code>self</code> <p>Timer instance</p> Source code in <code>suthing/timer.py</code> <pre><code>def __enter__(self):\n    \"\"\"Start timing on context enter.\n\n    Returns:\n        self: Timer instance\n    \"\"\"\n    self.start = self.timer()\n    return self\n</code></pre>"},{"location":"reference/core/#suthing.timer.Timer.__exit__","title":"<code>__exit__(*args)</code>","text":"<p>Stop timing on context exit and calculate elapsed time.</p> Source code in <code>suthing/timer.py</code> <pre><code>def __exit__(self, *args):\n    \"\"\"Stop timing on context exit and calculate elapsed time.\"\"\"\n    end = self.timer()\n    self.elapsed = end - self.start\n    self.mins = int(self.elapsed / seconds_per_minute)\n    self.secs = int(self.elapsed - (self.mins * seconds_per_minute))\n</code></pre>"},{"location":"reference/core/#suthing.timer.Timer.__init__","title":"<code>__init__()</code>","text":"<p>Initialize timer with default settings.</p> Source code in <code>suthing/timer.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize timer with default settings.\"\"\"\n    self.timer = default_timer\n    self.mins = 0\n    self.secs = 0\n    self.elapsed = 0\n</code></pre>"},{"location":"reference/core/#profiler","title":"Profiler","text":"Source code in <code>suthing/decorate.py</code> <pre><code>class SProfiler:\n    def __init__(self):\n        self._accumulator: defaultdict[str, list] = defaultdict(list)\n\n    def add_metric(self, hkey, metric_key=None, value=0):\n        self._accumulator[hkey] += [value]\n\n    def view_stats(self):\n        return deepcopy(self._accumulator)\n</code></pre>"},{"location":"reference/core/#comparison","title":"Comparison","text":"<p>Deep comparison of two objects.</p> <p>Recursively compares nested dictionaries and iterables. Strings and dicts are treated as atomic values.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Any</code> <p>First object to compare</p> required <code>b</code> <code>Any</code> <p>Second object to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if objects are equal, False otherwise</p> Source code in <code>suthing/compare.py</code> <pre><code>def equals(a: Any, b: Any) -&gt; bool:\n    \"\"\"Deep comparison of two objects.\n\n    Recursively compares nested dictionaries and iterables.\n    Strings and dicts are treated as atomic values.\n\n    Args:\n        a: First object to compare\n        b: Second object to compare\n\n    Returns:\n        True if objects are equal, False otherwise\n    \"\"\"\n    if isinstance(a, dict) and isinstance(b, dict):\n        if a.keys() != b.keys():\n            logger.error(f\"a: {a.keys()} ; b: {b.keys()}\")\n            return False\n        else:\n            return all([equals(a[k], b[k]) for k in a.keys()])\n    elif (isinstance(a, Iterable) and not isinstance(a, excluded_types)) and (\n        isinstance(b, Iterable) and not isinstance(b, excluded_types)\n    ):\n        return all([equals(ea, eb) for ea, eb in zip(a, b)])\n    else:\n        return a == b\n</code></pre>"}]}